# State Machine Scripts & project assembly
The purpose of this github page is to provide you with the tools and explanations to set up a fully compile-able arduino folder complete with state machines structures, software timers, debounced button reading and other supplemental modules. Though it is ment for somewhat more experienced programmers I welcome new commers to try this out.

#My motivation
When I was still learning for my bachelor degree in electronics, I had to write a paper about a topic of choise and I wrote a paper about bug prevention. Programming without bugs is very difficult to prevent. And on the level on which we program it is next to impossible. There are however things we can do. If you start a new project, you want to be able to do

When I started with my first 'real' job, I had to program a bicycle wheel taping machine. And I started out in C. Though the machine was not that complicated, I had difficulty doing the job. During development of the software for this machine and following machines, a lot of time went into adjusting the structure of the software. The taper software currently still exists out of a switch-case which uses numbers for case-labels and where state++ is used to transist from state to another. The readability is poor and it is an annoying job to make changes. The software came with lots of bugs, of which most were avoidable.

All software in the company was a complete mess. It was undocumentated, comments were in dutch and english. the states of their simplisitc state machines were not modulair. 'inc state' or in C 'state++' was used a lot instead of constants, every state had a label of letters and numbers instead of names and some files contained 20000 lines of code. It is still a payne to add states. There was no methods for an entry state. One-time-only stuff which had to happen for a state had to happen in the previous state. Adding a new state ment screwing arround with numbers and transplanting parts of codes. And the worst part, their version control was a complete mess. In some folders there were several extensions to be found; .ASM, .A, .BAC, and no extension. Alles files had the same content, on top of that the entire folder was copied so you'd have folderX (Copy 18) present. And yes 18 was the highest copy number I came accros.

With all my knowledge I obtained from coding myself, coding with other people, bugs, looking at folder (copy 18) and undocumentated and poorly written software. I realized that some drastic changes were needed. Some of the things I learned:

- how to implement a well-written modulair state machines
- how to manage project files.
- how macros can actually increase readability
- how to work with git

When writing my paper about preventing bugs was, I learned that 'repeatability' was part of preventing bugs. With this I mean the ability to reproduce earlier achiefed results without bugs. And this triggered something within me. When taking all my learned lessons in account I came to the one logical conlusion, people make a lot of mistakes. The one logical solution? Code generation.

# Code generation.
The solution to tackle as much problems as possible is to generate as much code as possible. The simple python and shell scripts I have developed can do the following things:

- They can generate entire state machine skeletons using a computer made state diagram
- They can assembly a fully arduino compilable projec folder
- They can create files for software timer
- IO can be generated using a simple text file

Further more I am adding supporting modules for SW such as a library to debounce buttons and listen to rising and falling flanks. Libraries for keypads as well for RTC modules will also be in this folder.

The scripts will be used in the alarm clock example to set up an entire new project. I will show all steps which must me made for setting up a project. For this we will use a checklist.

# My state machine implementation

## How they tick

There are an infinite ways to make a finite state machine or FSM. I have seen my share in terror in some of the wrong ways and in some of the complicated ways.

Therefor I devised a state machine which is as human readable as possible. I use macro's to mold my function into states and state machines. Most 'good programmers' are 100% allergic for macro's and they always cry the same phrase: "by replacing code by non-standard code, you make your code harder to read for other people". In fact these people are allergic to all code which is not standard. I am here not only to remind these people that this is not a proven fact, I am here to prove the opposite of this 'claim'. The macro's I use are written so that you do not even have to know how they precisely look like. Besides this, the macros are generated by scripts, the usage of these macros are also generated by scripts and they are generated above the first usage. So if you really want to see how they look like, scroll up. And if you really have to look how they are used, just scroll down.

Before I show some code I'll explain briefly how my state machines work. And why I have chosen for that manner.

My state machine exists out of a switch-case of which every case performs a function call to an other function, the state. This state function returns true when the state is finished. When that is the case, the switch-case will select a new function.

The decision which state is next to be executed is taken in the switch case. All other code (the states) are elsewhere. The advantage of this is that the entire flow of the SM is caught within a relative small switch-case which ususally fits in a single page.

The states themselfes consist out of 3 parts; the entryState, the onState and the exitState. The entry state is executed once on the first iteration of the state. From that point on, the entryState will be executed as long as the exitFlag is not set. Once this flag is set, the exitState will be executed. The exitState will return true when it is done, this will signal the SM that the state is finished. Though we need 2 flags per SM to work, this structure allows for great versability. Especially with the SW timer implementation every state can have a time out.

## the code

The code uses four macros for. Some people claim that macro's are ever a bad idea, that they make code harder to read because you use non-standard words and you can create a debug hell for yourself and for others. Point 1 is simply not true. Point 2 on the other hand can be true, but this is also perfectly avoidable. You can testthe macros before you start using them on 200+ places to prevent the debug hell.

Macros are just a tool of the language. You just have to use them right. The states I developed all look like:
```
State(stateName) { // the state 
	entryState {
		
	}
	onState {

		exitFlag = true; }
	exitState {
		
		return true; } }
...
...
State(someState) { // different macro for the state machine
	nextState(someOtherState,0); } // when 'someState' is finished, 'someOtherState' will run.
```

Given the information that you are looking at a state of a state machine which is proven to work. You should be able to figure out how to read it and how to use it. You do not even have to know the macro's precisely look like for it. The macros are however to be found above the SM in code.

If I expand the macro's we would get:
```
static bit someStateF(void)() {
	if(runOnce) {
		
	}
	runOnce = false;  
	if(!runOnce) {

		exitFlag = true; }
	if(!exitFlag) return false; 
	else {
		
		return true; } }
...
...

break; case someState: if(someStateF()) {
	nextState(someOtherState, 0); }
```
You now see how the states or functions actually work. Notice that there is a captital F appended to the state name. For states I often use an enum. Mainly because the actual binary number of the state is not important. The state functions cannot have the same name as the enumerated states. Therefor we add the letter 'F' of function for the function.

Also note that a new variable appeared 'runOnce'. May it be clear that this variable is used to handle the entryState. 

The macro's hide the runOnce flag, they hide the F behind the state names, they transform a typical C function in a 'State' and they modify a switch-case into a state machine. I just hide the things that we do not have to see. We do not have to see that every case has a break, we don't have to see in every state how the entryState works.

In short I move as much as 'irrelevant' information to the background as I deemed wise.

## the macros

Though I have already gave some hints on how they look like, here are the macro's:
```
#define entryState if(runOnce) 
#define onState runOnce = false; if(!runOnce)
#define exitState if(!exit) return false; else

#define State(x) static bit x##F(void) // for the states
#undef State

#define State(x) break; case x: if(x##F()) // for the state machine
#undef State
```
The macros are always directly above where they are used. So you can always find and read them above the states and state machines. That you don't have to know them, does not mean it is a bad idea to know them.

There is one tiny drawback of the macro's they add a little bit of overhead. The runOnce flag is cleared every iteration for as long as the state is active. The if statement behind it, is also a bit overhead. I may in fact alter this one. I believe that the if(!runOnce) can be deleted altogather.

## the entire package.

Now I'll discuss all code of the state machine and the code arround the state machine. The state machine on it's own is a function which uses a switch-case to call the state functions.

```
#define State(x) break; case x: if(x##F())
extern bit newWals(void) {
	if(enabled) switch(state){
		default: case newWalsIDLE: return true;

		State(powerOff) {
			nextState(startPosition, 0); }

		State(startPosition) {
			nextState(startMotor, 0); }
...
...
		break;}
	else if(!stateT) enabled = true;
	return false;}
#undef State
```
This is the entire state machine function. In the first lines you notice a variable called 'enabled' and the default case which returns true. The enabled flag allows the state machine to run. It is used to allow for inter-state delays. It may be that you want to wait an x ammount of time between states. This delay (non-blocking) is set by filling in a value for the 2nd arguement of the following function. 

```
static void nextState(unsigned char _state, unsigned char _interval) {
	state = _state;
	if(_interval) {
  	stateT = _interval;
		enabled = false; }
	runOnce = true; }
```
This function is called every time when a state is finished. The function handles the next state, 'runOnce' flag, 'exitFlag' flag and optionally the 'enabled' flag and the the state timer (stateT). How the enabled flag works, will be discussed in the software timer chapter.

The return function of the state machine is typically only used for nested state machines. Nested state machines typically come to an end. When they reach this end, they will jump to the IDLE state. The IDLE state will return true. This signal the 'caller' or 'parent state machine' that the nested state machine is finished. If the state != IDLE, the state machine ever returns false.

This feature is not present in 'main state machines'. Main state machines typically do not remain in an IDLE mode. They can but they don't have to return true or false as they are called from the main.

## The timers.
At our work we were at first using a beatiful piece of SW timers. We had a function `start(foo, intervalTime)' and `trigger(bar, delayTime)'. These function would dynamically alocate a sw timer and hook it up the address of the function. It worked well but later on we got into trouble with the overhead which came with it. Long story short... I copied the SW timer usage of our now-retired assembly programmer. In this timer ISR he made blocks with a separate interfals for 2ms (<- ISR timer), 10ms and 100ms. Within these blocks he'd decrement all software timers.

The ISR looks as follows:
```
ISR(TIMER2_OVF_vect) {
static unsigned char _1ms, _10ms, _100ms;
_ms += 1;
//	add 1ms timers here

if(!(_1ms % 10)) { // if 10ms passed
	_1ms = 0;
	_10ms += 1;
	// add 10ms timers
	if(debounceT) debounceT -= 1;

if(!(_10ms % 10)) { // if 100ms passed
	_10ms = 0;
	_100ms += 1;
	// add 100ms timers
	if(stateT) stateT -= 1;

if(!(_100ms % 10)) { // if 1000ms passed
	_100ms = 0;
	// add 100ms timers
	if(timerWith100msInterval) timerWith100msInterval -= 1;
	if(anotherTimerWithaTooLongName) anotherTimerWithaTooLongName -= 1; // some dummy values to illustrate the use

}
}
}
```
Please do not be upset about the strange indentation style here. I found this to be more logical for this particular function than any other default method.

This method simple decrements those timers which aren't 0 yet. Because of the devision of timer bases, all timers can be of an 8-bit type. This safes memory and increases performance alike. 

The typical arduino method with millis() is to substract 2x 32 bit variables and compare the result with a 3rd 32 bit variable.

The best part of this SW timer is that it is generated for us. All main state machines have their own timer variables within the timer files. The name of these timers are the names of the state machines with the captial T appended. Furthermore, timers for default functions are also added. As of now I only have debounceT implemented to debounce buttons and or sensors.

This incredibly simple method has proven to be quite dynamic and easy to use. A list of the features:
- Every state can have it's own time out if needed
- You can build a non-blocking in-state delay for a certain state
- You can implement a delay between two following states (using the nextState() function).

### The time-out usage
A time out for a state can be needed depending on your use case. It can be realized as follows:
```
State(swingArmOutside) {
	entryState{
		stateT = 200; // 2000ms delay
		arm = 1; }	// we swing out an arm, and awaits it's sensor
	onState{
		if(sensor) {
			// sensor is made on time
			errorFlag = false;
			exitFlag = true; } 
		else if(!stateT) {
			// time has expired
			errorFlag = true;
			exitFlag = true; } }
	exitState{
		// no action need
		return true; } }
```
When this state is finished 'errorFlag' can be true or false. The state machine, which is now ready to pick a new state, may read this flag in order to determen which state it should select.
```
...
State(swingArmOutside) {
	if(errorFlag) 	nextState(ALARM,0);
	else 		nextState(swingArmInside,0); }
...
```




When interval != 0, the enabled flag is set at 'false' and the interval value is loaded in the timer. This timer decrements until it reaches 0.

When the enabled flag is false, the SM will not be called, instead the state timer is polled in the else-if statement. Once the timer reached 0, 'enabled' will be set at 'true' and the next state will be executed.





