# My State Machine implementation

During ~four years of code developing for complicated machinery. My code structure began to evolve into what it is today. I started out with messy switch cases for state machines and now I have written an abstract state machine class in C++.

With this class you can assemble a complete well structured state machine in. The class has methods for handling the transitioning between state, one-time-only code for entering and leaving states and the class comes with timing functionality.

A complete state machine structure essentially exists out of these three parts.
- the state functions
- the state machine
- the library

Empty state function as well as the state machine can be generated by a python script using a graphical representation of a state machine. How this works is described in the readme file.


# The state functions

To achieve a clear overhead I made a split between the part which actually does something and the part which handles the flow of the program.

The first part is properly called the stateFunctions. A freshly generated stateFunction looks like this:

```c
stateFunction( stateName )  // the state function
{ 
    if( sm.entryState() )    // runs once upon entering this state function
    {

    }
    if( sm.onState() )      // runs continously until exit() is run
    {

        sm.exit() ;         // launches the exitState and terminates this state function
    }
    if( sm.exitState() )    // is run once after exit() is called
    {

    }

    sm.endState() ;         // signals state machine when function is finished.
}

```
You can clearly see that this stateFunction is split into three sub-parts, named ```entryState```, ```onState``` and ```exitState```. May it be obvious that code in the entryState is only run once as first when this stateFunction is called for the first time.

The onState code is run continously until the ```exit()``` method is called. When this happens the code of the exitState is also run once.

In this example you may have noticed that the phrase stateFunction is not standard C++. It is in fact a simple macro. If we expand the macro we would get:
```c
static bool stateNameF(void)() 

```
It is just a regular function which returns a boolean type.

Notice that, in the expanded version, there is a captital F (F for Function) appended to the state name. The state names themselves are already constants. As such a function cannot have the same name. Therefor I used a macro to 'secretly' append the capital letter F. I personally also like the fact that the macro identifies a regular function as an actual stateFunction which belongs to a state machine.

# The state machine
The state machine on it's own is a function which performs function calls to the above stateFunctions. Once the called stateFunction returns ```true```. This state machine may pick a new state to be called with the function ```nextState()```

Freshly generated it may may look as follows:


```c
extern uint8_t name_of_stateMachine(void)
{
    STATE_MACHINE_BEGIN

    State( x ) {
        nextState( y, 0 ) ; }

    State( y ) {
        nextState( z, 0) ; }

    State( z ) {
        nextState( x, 0) ;
        nextState( y, 0) ; }

    STATE_MACHINE_END
}
```
You are looking at a state machine with 3 poorly named states; x, y and z.

Experienced programmers will notice again that there is non standard C++ code present. I will now show the exact same code looks like with all macros expanded:

```c
extern uint8_t name_of_stateMachine(void)
{
    if( sm.run() ) switch( sm.getState() ) { // STATE_MACHINE_BEGIN

    break ; case x:                          // State( x )
        if( xF() ) {
            sm.nextState( y , 0 ) ; }

    break ; case y:                          // State( y )
        if( yF() ) {
            sm.nextState( z, 0 ) ; }

    break ; case z:                          // State( z )
        if( zF() ) {
            sm.nextState( x, 0 ) ;
            sm.nextState( y, 0 ) ; }

        break;                                //  STATE_MACHINE_END
    }

    return sm.getState() ;
}
```
The STATE_MACHINE_BEGIN macro is a disguise for a switch case. This switch case is called when ```sm.run()``` returns ```true```. I will explain how that works in the following chapter. This macro also includes an opening curly bracket

The ```State( x )``` macro is an interesting one. This macro forms a break statement followed by the case label with the state name and lastly it performs a function call to the state name + the capital F, this is the same letter F as we have seen in the names of the accompanying state functions. It is this what calls a stateFunction.

Take note here that we call the stateFunction from inside an if-statement. If you remember, the stateFunctions return ```true``` once they are finished. That means that the method ```sm.nextState()``` is called every time when a certain state has finished.

The STATE_MACHINE_END merely exists out of the final break-statement followed by a closing curly bracket.

You may have noticed that the ```sm.nextState()``` method takes the next state (hence the name) as argument as well as the number 0. This number will be explained in the following chapter. In short, this number may be used to set an interval between 2 following states.

This state machine needs almost no filling in. There is however one part which needs filling in. State 'z' can transition to both states x and y. You have to specify in this stretch of code why which state is next.

```c
State( z ) {
    if( /* condition */ ) nextState( x, 0) ;
    else                  nextState( y, 0) ; }
```



# The state machine library
So far you have seen the following methods who belong to the state machine class. In order of appearance you have seen:
```c
// in state functions
uint8_t entryState()                    // to be called from inside an if-statement. Ensures that code is only run once when entering a state
uint8_t onState()                       // can be left out, simply returns 1 so code always run
void    exit()                          // triggers current state to run the exitState
uint8_t exitState()                     // runs code only after the exitFlag is set
uint8_t endState()                      // signals the state machine if the state function is finished 

// in state machine
uint8_t run()                           // used to handle time delays between states, it is standard called via a macro
uint8_t getState()                      // returns the current state
void    nextState( uint8_t, uint32_t )  // transitions from one state to another, with or wiithout a delay
```
The ones you haven't seen yet
```c
void    setState( uint8_t _state )      // sets state machine to run a state of choise, used for initialization
void    reboot()                        // allows the entryState to run again, Can be usefull from time to time
void    setTimeout( uint32_t time2run ) // sets a timeout time in milliseconds
uint8_t timeout()                       // returns true when the timeout occurs
uint8_t repeat( uint32_t interval)      // keeps repeating code with _interval_ time, can be called in any _onState_

```
These last three methods can be used for timing purposes inside the state functions. The methods ```setTimeout()``` and ```timeout()``` work togather. With ```setTimeout( time )``` you can set a timeout time (like the name says). The method ```timeout()``` will return true when this time expires. The method ```repeat( interval )``` will also return true like ```timeout()``` but this one will reload itself with the given interval. Take note that these functions use the same timer under the hood, therefor you cannot use ```timeout()``` in combination with ```repeat()```. You do can combine ```setTimeout()``` with ```repeat()``` if you have the need for a delayed action of ```repeat()```. Otherwise ```repeat()``` will already return true on the fist call.

 Under the hood the timer methods works with ```millis()```. The state machine class is fully compliant with hardware abstraction layer of Arduino.

Below there is an example of how you can use the timeout function. This example also shows you how easy it is to fill in a state function.
```c
State( swingArmOutside )
{
    if( sm.entryState() )
    {
        sm.setTimeout( 2000 ) ;     // 2s timeout time
        digitalWrite(arm, HIGH) ;   // swing out arm, and await sensor
    }	
    if( sm.onState() )
    {
        if( digitalRead( armSensor) ) // sensor is made on time
        {
            errorFlag = false;      // clear error flag
            sm.exit() ;             // exit this state
        } 
        else if( sm.timeout() )     // time has expired
        {
            errorFlag = true;       // set error flag
            sm.exit() ;             // exit this state
        }
    }
    if( sm.exitState() )
    {
        if( errorFlag )
        {
            digitalWrite(arm, LOW) ;
            Serial.println("Arm is stuck") ;
        }
        else
        {
            Serial.println("everything OK") ;
        }
    }

    sm.endState() ;
}
```
In the entryState we only set an output for the arm and we set a timeout condition.

If either the sensor is made or the time expires, ```sm.exit()``` is called and the exitState is run. Depending on what happens first the errorFlag is either set or cleared. If this flag is set, the arm will be sent back and a different message will be shown.

This same ```errorFlag``` variable can also be used in the state machine to pick which state is the next to run. 

```c
State( swingArmOutside ) {
    if( errorFlag ) nextState (ALARM, 0 ) ;
    else            nextState (swingArmInside, 1000 ) ; } // swing arm back inside 1 second later

State( swingArmInside ) {
    if( errorFlag )  nextState (ALARM, 0 ) ;
    else             nextState (foobar, 0 ) ; }

State( ALARM ) {
    nextState (ALARM, 0 ) ; }

State( foobar ) {
    ....
```
The supplementing ```repeat()``` function. You can use it as follows:

```c
State( repeatTest )
{
    if( sm.entryState() )
    {
        Serial.println("entering state repeatTest");
        // no action need
    }	
    if( sm.onState() )
    {
        if( sm.repeat( 500 ) )
        {
            foobar() ;                      // foobar is called every 500ms
        }
        if( serialByte == 'S' ) sm.exit() ; // until we send an 'S' from serial monitor
    }
    if( sm.exitState() )
    {
        Serial.println("leaving state repeatTest");
        // no action need
    }

    sm.endState() ;
}
```
## Under the hood in more detail
if you are interested in how the timing functions work and what ```sm.run()``` precisely does, keep on reading.

This is the source of the `nextState()` method. You see that this method clears the `exitFlag` which is used for the exitState and the `runOnce` flag is set to fire the entryState of the next state.

If a value other than 0 is entered for the interval, the enabled flag is cleared, the current time is stored and the interval is loaded.

```c
void StateMachine::nextState( uint8_t _state, uint32_t _interval ) 
{
    exitFlag = 0 ;
    runOnce = 1 ;
    if( _interval )
    {
        enabled = 0 ;
        prevTime = millis() ;
        interval = _interval ;
    }
    state = _state ;
}
```
Now we are gonna to look at `run()`. This function is called before the switch-case of the state machine. If `run()` returns false, the state machine will not run. If the `enabled` flag is cleared. This function will continu to monitor if the interval, set in `nextState()` expires. If it has, the 'enabled' flag will be set again, allowing the state machine to run the next state.

```c
uint8_t StateMachine::run()
{
    if( enabled == 0 )
    {
        if( millis() - prevTime >= interval )
        {
            enabled = 1 ;
        }
    }
    return enabled ;
}
```
The _sub state_ function, `entryState` , `onState` and `exitState` do not do more than handling some of the flags. The `onState` could actually be left out entirely, but for the sake of syntax, consistency and consistency of syntax, I recommend using it anyways. It simply makes your code look prettier and more organized.

```c
uint8_t StateMachine::entryState()
{
    uint8_t retVal = runOnce ;
    runOnce = 0 ;
    return retVal ;
}

uint8_t StateMachine::onState()
{
    return 1 ;
}

uint8_t StateMachine::exitState()
{
    return exitFlag ;
}

```
By now can propably guess what `exit()` does? I'll show it anyways. It just sets the `exitFlag` so `exitState()` can do it's thing
```c
void StateMachine::exit()
{
    exitFlag = true ;
}
```
The method 'endState()' returns the `exitFlag` to signal the state machine if the exitState is run or not
```c
uint8_t StateMachine::endState( )
{
    return exitFlag ;
}
```
The timer function look as follows:
```c
void StateMachine::setTimeout( uint32_t time2run )
{
    prevTime = millis() ;
}
    
uint8_t StateMachine::timeout()
{
    if( millis() - prevTime >= interval ) return 1 ;

    return 0 ;
}

uint8_t StateMachine::repeat( uint32_t _interval )
{
    if( millis() - prevTime >= _interval )
    {
        prevTime = millis() ;
1        return 1 ;
    }
    return 0 ;
}
   
```
The last function worth mentioning is the `reboot()` method. It only sets the runOnce flag again so one can 'redo' the `entryState`. This can be usefull from time to time. 

```c
void StateMachine::reboot()
{
    runOnce = true ;
}
```
I have a practical example of the `reboot()` method. I used it to display the last selected menu on an LCD.

With the buttons 0-9 you can select a currentMenu . If a new currentMenu is selected, `sm.reboot()` is called to print the new menu on the LCD.
```c
StateFunction( Menu )
{
    if( sm.entryState() )
    {
        clear() ;
        printAt(0, 0, text[ currentMenu ] ) ;      // display first text
        printAt(0, 1, F("0-9 = SEL. MENU") ) ;
    }
    if( sm.onState() )
    {
        if( retVal != 1 ) return 0 ;
        if( key >= '0' && key <= '5' )
        {
            currentMenu = key - '0' + 1 ;
            sm.reboot() ;
        }
        if( key == 'D' || key == '#')
        {
            sm.exit() ;
        }
    }
    if( sm.exitState() )
    {
        if( key == '#') currentMenu = 5 ;
        else            currentMenu -- ;
    }
    return sm.endState() ;
}
```

---
## Calling a state machine.
A state machine always returns it's current state. The return value can be used as a signal to let state machines communicate with eachother. And you can monitor if a state machine is finised. By default there is always an idle state present which always returns 0.

If you create a sphere diagram with a or several spheres which have no outgoing arrows, than the state machine will automatically enter the idle state after those states are executed. 

See below example, it consists out of two state-machines in a single file. This is done because both state-machines can not be run in the same time. They are ment for rolling in and out a bicycle wheel and this cannot occur at the same moment.

![handleWheel](https://raw.githubusercontent.com/bask185/State-Machine-Scripts/master/images/handleWheel.png)

The 2 bottom states have no outgoing arrows. This means that after these states are finished, the state machine will automatically default to the IDLE states which will signal the calling routine that the wheel has either rolled in or out. The calls to `nextState( HandleWheelIDLE )` are generated for you by the assembly script.

```c
State( lowerInnerWheelStop ) {
    sm.nextState( wheelIsInMachine, 0 ) ; }

State( wheelIsInMachine ) {
    sm.nextState( HandleWheelIDLE, 0) ; } // <<--- idle, generated by script

State( stopWheel ) {
    sm.nextState( waitnextMachine, 0) ; }

State( ejectWheel ) {
    sm.nextState( wheelIsOutmachine, 0 ) ; }

State( waitnextMachine ) {
    sm.nextState( ejectWheel, 0 ) ; }

State(wheelIsOutmachine) {
    sm.nextState( HandleWheelIDLE, 0 ) ; } // <<--- idle generated by script
```
A state-machines can also be easily called from inside another state machine. Below is one example of a stateFunction which calls this wheel handle module. As soon as the wheelHandle state machine returns 0, the next state can be picked.

```c
stateFunction( rollIn )
{
    if( sm.entryState() )
    {
        handleWheelSetState( waitOutputRail ) ; // initialize state machine for rolling in a wheel.
    }
    if( sm.onState() )
    {
        if( handleWheel() == 0 )      // function call to wheelHandle
        {
            exitFlag = true; 
        }
    }
    if( sm.exitState() )
    {
        // no action needed   
    }

    sm.endState() ;
}
```
This is essentially everything to it. With just two lines of code you can initialize a state machine, run it and monitor when it is finished

## State Diagrams in yEd
---

Nowadays this is where my new SW projects begin. I write down the basic operation in the form of simple state diagrams in the program yEd. This is as much needed for code generation as it is important for your own documentation. It helps you and your co-workers read and navigate through the code.

The state diagrams are also needed for actual code generation. yEd stores the diagrams in a .graphml in ascii format which will feed a python script to generate all state machine skeletons. This action is done once. When states are to be removed or added, that has to be done manually. It remains of great importance that you keep updating the diagram. It is even better to first modify the diagram before you modify the SW.

This will greatly increase the effectiveness of maintaining and altering SW. I will show 2 examples state diagrams of a machine before I started and when I was finished. This particular machine was written in Assembly. Yet the basic principles remained the same.

These are 2 main state machines for 2 rim (un)loading arms which run parallel.

If you look in detail you'll see that the first draught came close to the end diagram

![Pons1](https://raw.githubusercontent.com/bask185/State-Machine-Scripts/master/images/pons1.png?raw=true)
![pons2](https://raw.githubusercontent.com/bask185/State-Machine-Scripts/master/images/pons2.png?raw=true)

During code developing, the SMs became more and more complex. There were like 6 or 7 versions. These were not used for the generation part which was not yet finished at the time (yes I can also generate assembly code for work). That is why I have drawn 2 main state machines and a supplementing one on a single document.

Even though this was in assembly it remained extremely easy to make every alteration. The sphere diagrams were an indespensible tool for developing the program. And the state machine structure as I developed proved very effective, dynamic and modulair.


It is important to remember that these state diagrams are kept as simple and orderly as possible. The reasons or state-transition-condtions which control the flow of the state machine should not be drawn in the state diagram because of these reasons:
- After the code is generated, the state diagram will act primarly as a reading guide. Therefor we should not add too much information
- The reasons or conditions are often not yet known at the moment you are creating the diagram.
- Because of the clarity of the state diagram, it is easier to read the conditions in the SW instead
- It may be that the conditions are too complex to try to draw them in the diagram.

Wheter all of these reasons are valid or not, if you add them all togather it would be illogical to try to draw the transition conditions.

An example of a state machine followed by one nested state machine:

![taper machine main SM](https://raw.githubusercontent.com/bask185/State-Machine-Scripts/master/images/nestedSM.png)

The following one is the 'stabilize' nested state machine which I call 'kraken' (element out of native language)

![stabilize nested SM](https://raw.githubusercontent.com/bask185/State-Machine-Scripts/master/images/kraken.png)

The taping module is as almost as big as these 2 state machines togather. You can imagine how it would look like if it would be one single state machine. It would be rather big. Ofcourse with the sphere diagram you would still have no difficulty maintaining it, but to split some of the tasks into nested SMs the 'whole package' becomes much more clearer.

There is only 1 rule which must be obeyed when making a state diagram.
- Names must be valid C, so don't uses space or other strange characters 

---